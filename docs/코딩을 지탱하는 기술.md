# 코딩을 지탱하는 기술

[코딩을 지탱하는 기술](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788994774480&orderClick=LAG&Kc=)

이 책은 전반적으로 2가지 기준에 따라, **특정 언어에 국한되지 않는 보편적인 지식**을 알려주고 있다.

1. 언어간의 비교

    *"C언어에서 0은 거짓이고, Ruby에서는 0이 참이다"*

2. 언어의 발전과정과 역사

​

### 언어

언어는 도구다. 자신의 목적에 적합한 언어를 선택해 적재적소에 사용해야 한다.

​

예를 들어, C++은 빠른 실행 속도를 중시하며, Python은 다른사람의 코드를 쉽게 해석할수있는 가독성에 중점이 있다. PHP는 웹서비스를 쉽게 만들게 해주나 문장처리를 잘하진 못한다. 이는 Haskell, OCaml 같은 ML(Meta - Language)처리 계통 언어가 적합하다. 어느 언어가 더 낫다는 것은 무의미한 논쟁이다.

​

### 문법, 처리 흐름 제어, 함수

모두 같은 말을 하고 있다. 결국 언어에 의존하지 않는 보편적인 지식과 원리라는 말을 하려는 것 같다.

​

### 에러 처리

실패를 전달하는 방법은 크게 2가지가 있다.

1. 반환값으로 알린다
2. 실패하면 점프한다

​

1번은 반환값 확인을 잊어버려서 실패를 놓칠 수 있는 문제가 있다.

그래서 2번이 오랜시간 연구되어 왔고, 이것이 지금의 여러 언어들이 지원하는 **'예외 처리'** 구조이다.

​

한편, 예외처리에도 몇가지 문제가 있다.

하나는 함수의 출구가 여러개라서 '짝을 이루는 처리'를 바르게 짝지어 처리하기 어렵다는 문제이다.

또 함수가 어떤 예외를 던질지 그 함수의 코드를 봐도 알수없다는 문제가 있다.

​

### 이름과 Scope

- 전역, 동적 스코프
- 정적 스코프 (Java)

​

### 형(Type), 컨테이너와 문자열

결국 대상을 표현하려는 것. 그 방식은 역시 언어에 따라 다르다.

​

### 병행 처리

병행성 : 이 장에서 다루는 프로그래밍 측면의 병행성. process, thread와 관련

병렬성 : 하드웨어 측면의 개념

​

처리를 변경하는 2가지 방법 )

1. 협력적 멀티테스크
2. 선점적 멀티테스크(Preemptive Multi-task) : 일정시간에 교대

​

Race Condition의 3가지 조건 )

1. 2가지 처리가 변수를 공유하고 있다
2. 적어도 하나의 처리가 그 변수를 변경한다
3. 한쪽 처리가 한 단락 마무리되기 전에, 다른 쪽의 처리가 끼어들 가능성이 있다.

​

=> 이 3가지 조건중 하나라도 제거할수 있다면 병행실행에 안정된 프로그램을 만들 수 있다.

​

조건 제거를 위한 노력 )

1. 공유하지 않는다 : Process와 Actor 모델
2. 변경하지 않는다 : const, val, immutable
3. 끼어들지 않는다
    - 협력적 스레드의 사용 : fiber, coroutine, Green thread
    - 끼어들면 곤란한 처리에 표시하기 : Lock, Mutex, Semaphore

​

Lock의 문제점 : Deadlock과 합성불가

⇒ Transactional Memory를 이용해 해결하려 함

​

### 객체와 클래스

객체지향, 현실세계의 사물모형을 만들기 위한 노력들 )

1. 모듈, 패키지
2. 함수도 해쉬에 넣자
3. Closure
4. Class

​

클래스의 3가지 역할 )

1. 결합체를 만드는 생성기
2. 어떤 조작이 가능한지에 대한 사양
3. 코드를 재사용하는 단위

​

### 상속을 통한 재사용

상속의 3가지 측면 )

1. 일반화/특수화 : 부모 클래스로 일반적인 기능을 구현하고, 자식 클래스로 목적에 특화된 기능을 구현한다.

    (Q. 자식은 부모의 일종인가? : Yes)

2. 공통 부분을 추출 : 복수 클래스의 공통 부분을 부모 클래스로서 추출하면 좋다.

    (Q. 자식은 부모의 일종인가? : No)

3. 차분 구현 : 상속후 변경된 부분만을 구현하면 효율이 좋다.

    (Q. 자식은 부모의 일종인가? : No)

​

상속은 양날의 칼이다. 과도하게 사용하면 복잡도가 증가한다. 적절한 상속트리의 깊이를 갖도록 조절.

​

리스코프(Liskov)의 치환 원칙

​

다중 상속 )

클래스의 역할 : '코드 재사용을 위한 단위' vs '클래스는 분류'

다중 상속을 사용하면 코드 재사용에 편리하지만, 충돌의 문제가 발생할 수 있다.

​

⇒ 해결책

1. 다중 상속 금지 (Java)

    대신 **위임(delegation)**의 개념이 발달하였다.

    사용하고 싶은 코드를 가진 클래스 객체를 만들고, 필요에 따라 해당 클래스에 처리를 맡긴다. 상속을 통해 형이나 이름 공간까지 함께 물려받는것이 문제이기 때문에, 단순히 객체를 보유하기만 하면 문제를 해결할 수 있다.

    위임의 참조도 소스에 하드코딩하기 보다, 설정파일을 사용해 실행시 주입하는것이 편리하며, 이런 발상에서 **의존성 주입(Dependency Injection)**이 탄생하였다.

    (* Java는 다중상속을 금지하지만, 인터페이스는 가능)

2. 메소드 해결 순서를 고민한다​
3. 처리를 섞는다

    Mix-in

4. 트레이트(trait)

    클래스에는 2가지 상반되는 역할이 있다.

    **'인스턴스를 만들기 위한 것' vs '재사용 단위'**

    전자는 필요한 모든것을 가지고 완결된 형태의 큰 클래스.

    후자는 필요없는 기능을 갖고있지 않은 작은 클래스.

    트레이트는 후자의 작은 개념을 위한 것

​

---

총평 : 요즘 가장 많이 접하는 말. *'정답은 없다'*