# 자바 ORM 표준 JPA 프로그래밍 (김영한)

# Table of Contents

---

# 1장. JPA 소개

### 애플리케이션에서 SQL을 직접 다룰 때 발생하는 문제점

- 계층 분할이 어렵다
- 엔티티를 신뢰할 수 없다
- SQL에 의존적인 개발을 피하기 어렵다

### 객체와 RDB 사이의 패러다임 불일치 문제

- 상속
- 연관관계
    - 객체는 참조를 이용, 테이블은 외래키를 이용
- 객체 그래프 탐색
    - 객체는 마음껏 객체 그래프를 탐색할 수 있어야 한다
    - SQL을 직접 다루면 처음 실행하는 sql에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다
    - 그렇다고 연관된 모든 객체 그래프를 조회해 메모리에 올려 두는 것은 현실성 없다
    - JPA는 연관 객체를 사용하는 시점에 적절한 SELECT문을 실행해, 연관된 객체를 신뢰하고 마음껏 조회할 수 있다
- 비교
    - 동등성, 동일성
        - 동일성, Identity - 실제 인스턴스가 같다. ==
        - 동등성, Equality - 실제 인스턴스는 다를 수 있으나, 갖고 있는 값이 같다. equals()

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled.png)

### JPA란

- **JPA는 자바 ORM 기술에 대한 API 표준 명세**
- 대표적인 구현체로 Hibernate
- 통계 쿼리 같이 복잡한 쿼리보단, 실시간 처리용 쿼리에 더 최적화되어 있다
- JPA가 어려운 이유 : ORM은 OOP와 RDB 둘다 잘 이해해야 하기 때문
- JPA를 사용해야 하는 이유
    - 생산성
    - 유지보수성
    - 패러다임의 불일치 해결
    - 성능
        - 애플리케이션과 데이터베이스 사이에 계층이 하나 더 있으면, 성능 관점에서 시도해 볼 수 있는 것들이 많다.
        - 대표적으로 영속성 컨텍스트를 활용해, 쿼리를 두번 보내지 않고 조회한 객체 재사용 가능
    - 데이터 접근 추상화와 벤더 독립성
        - 애플리케이션과 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공해, 특정 DB 기술에 종속되지 않도록 해준다
    - 표준

# 2장. JPA 시작

- H2
    - H2는 JVM 메모리 안에서 실행되는 **임베디드 모드**와, 실제 DB처럼 별도의 서버를 띄워 동작하는 **서버 모드**가 있다.

- Dialect 방언
    - `org.hibernate.dialect.H2Dialect`
    - `org.hibernate.dialect.MySQL5InnoDBDialect`

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%201.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%201.png)

### JPQL

- JPQL은 엔티티 객체를 대상으로 쿼리 vs SQL은 DB 테이블을 대상으로 쿼리한다
- JPQL은 DB 테이블을 전혀 알지 못한다
- JPA는 JPQL을 분석해 적절한 SQL을 만들어 DB에서 데이터를 조회한다

# 3장. 영속성 관리

### EntityManagerFactory - EntityManager - Persistence Context

- 엔티티 매니저 팩토리
    - 설정 정보를 활용해 만들어진다
    - 앤티티 매니저를 만드는 곳이며, 생성 비용이 커 애플리케이션 전체에서 하나만 만들어 공유한다
    - ***여러 스레드가 동시에 접근 및 공유 가능***
- 엔티티 매니저
    - JPA 기능 대부분을 제공
    - 내부에 데이터소스(커넥션)를 유지하며 DB와 통신
        - 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다
        - 예를 들어, 트랜잭션을 시작할 때 커넥션 획득
    - 커넥션과 밀접한 관계가 있으므로, ***스레드간에 공유되거나 재사용하면 안된다***
- 영속성 컨텍스트
    - 엔티티를 영구 저장하는 환경 (직역..), 논리적 개념
    - 여러 엔티티 매니저가 한 영속성 컨텍스트에 접근할 수 있으나, 일단 지금은 1:1로 생각, 복잡한 상황은 11장 참고

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%202.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%202.png)

### 엔티티의 생명주기

- 비영속
- 영속
    - 영속 상태 - 엔티티가 영속성 컨텍스트에 의해 관리되는 상태
    - ex
        - em.persist()는 엔티티를 영속성 컨텍스트에 저장한다
        - em.find() or JPQL로 조회한 엔티티도 영속 상태
- 준영속
    - 준영속으로 만드는 3가지 방법
        - em.detach()에 의해 (삭제까진 아니고) 더이상 관리되지 않는 상태
        - em.close() or em.clear()로 영속성 컨텍스트를 닫거나 초기화해도, 관리되던 엔티티들은 준영속 상태가 된다
    - 준영속의 특징 & 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다
        - 거의 비영속 상태에 가깝다
        - 식별자 값을 갖고 있다. (한번 영속됬으므로, 비영속은 식별자 값이 없을 수 도 있음)
        - 지연 로딩을 할 수 없다
- 삭제

### 영속성 컨텍스트의 특징

- 엔티티를 식별자로 구분한다. 따라서 영속상태는 반드시 식별자 값(@Id로, PK와 매핑되는 값)이 있어야 한다.
- Flush : 트랜잭션을 커밋하는 순간, 영속성 컨텍스트의 변경내용을 DB와 동기화
- 장점
    - 1차 캐시
        - Map
        - JPA는 1차 캐시를 통해, 'REPEATABLE READ 등급의 트랜잭션 격리 수준'을 DB가 아닌 애플리케이션 레벨에서 제공한다는 장점이 있다.
    - 동일성 보장
    - 트랜잭션을 지원하는 쓰기 지연
    - 변경 감지, Dirty Checking
        - JPA는 엔티티를 영속성 컨텍스트에 저장할 때, 최초 상태를 복사해 저장한다. (스냅샷) 그리고 플러시 시점에 스냅샷과 엔티티를 비교
        - 변경 감지는 영속 상태의 엔티티에만 적용된다
        - 주의 - ***JPA의 기본 전략은, 엔티티의 모든 필드를 업데이트 한다***
            - 단점 - DB에 보내는 데이터 양이 증가
            - 장점 - 수정 쿼리가 항상 같아, 애플리케이션 로딩시 미리 생성해두고 재사용할 수 있다. DB도 이전에 한번 파싱한 쿼리를 재사용할 수 있다.
            - `@DynamicUpdate`, `@DynamicInsert` (Hibernate)
                - 필드나 저장 데이터가 너무! 많으면 본 애노테이션을 이용해, 동적으로 쿼리를 생성하는 전략을 택한다.
                - 보통 컬럼이 30개 이상 되면 기본 정적 쿼리보다 동적 쿼리가 빠르다고 한다.
                - 하지만, 한 테이블에 컬럼이 30개 이상 된다는 건, 설계상 책임이 적절히 분리되지 않았을 가능성이 높다.
    - 지연 로딩

### 플러시, Flush

- 영속성 컨텍스트의 변경 내용을 DB에 반영
- 영속성 컨텍스트를 플러시하는 3가지 방법
    - em.flush() 직접 호출
    - 트랜잭션 커밋시, 자동 호출
    - JPQL 쿼리 실행시, 자동 호출

        ```sql
        em.persist(memberA);

        query = em.createQuery("SELECT m FROM Member m", Member.class);
        List<Member> members = query.getResultList();
        ```

        - 이 상황에서 memberA는 영속성 컨텍스트엔 있지만 DB엔 아직 반영되지 않았다.
        - JPQL은 sql로 변환되어 DB에서 엔티티를 조회하는데, 아직 memberA가 DB에 없어 조회되지 않을 것이다.
        - 이런 문제를 예방하기 위해, JPQL을 실행할 때도 플러시를 자동 호출한다.

        ![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%203.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%203.png)

        - *Criteria, QueryDSL은 결국 JPQL을 편리하게 사용하기 위한 기술*
- FlushModeType.~로 모드 설정 가능
- 오해 - 이름만 보고 Flush를 '데이터를 지우는 것'으로 오해하지 말 것

### 병합, merge()

- 엔티티를 받아, 새로운 영속 상태의 엔티티를 반환
- merge는 준영속, 비영속을 신경 쓰지 않는다
    - 식별자 값으로 엔티티 조회되면 찾아 병합하고, 조회 안되면 새로 생성해 병합한다
    - 따라서 병합은 save or update 기능을 수행한다

# 4장. 엔티티 매핑

### 주의사항

- @Entity - 인자 없는 기본 생성자 필수
- @Table(uniqueConstraints=?), @Column(length=?, nullable=?) 등과 같은 *제약 조건들은 DDL을 통한 자동 생성시에만 적용*되고, JPA 실행 로직엔 영향을 주지 않는다.
    - 따라서 스키마 자동 생성 기능을 사용하지 않고, 직접 DDL을 만든다면 사용할 필요는 없다
    - 하지만 애플리케이션 개발자가 보고 알수있도록 *명시용*으로 쓸 수 있다

### 스키마 자동 생성 기능

- [hibernate.hbm2ddl.auto](http://hibernate.hbm2ddl.auto) 속성
    - create
    - create-drop
    - update
    - validate
    - none
- 운영 환경에선 create, create-drop, update와 같은 DDL을 수정하는 옵션을 사용해선 안된다. validate 추천
- 위의 속성들은 hibernate꺼다. JPA도 2.1부터 스키마 자동 생성 기능을 지원하는데, update와 validate는 안된다

### Naming Strategy

- 자바는 카멜 케이스, 데이터베이스는 언더스코어가 관례
- `hibernate.ejb.naming_strategy` 속성을 사용해, 이름 매핑 전략을 설정 가능
- 하이버네이트는 `org.hibernate.cfg.ImprovedNamingStrategy` 클래스를 제공
    - 테이블명, 컬럼명이 생략되면 자바의 카멜 표기법을 테이블의 언더스코어 표기법으로 매핑

### 기본 키 생성 전략

- 방법
    - 직접 할당
    - 자동 생성
        - IDENTITY
        - SEQUENCE
        - TABLE
    - AUTO
- DB 벤더마다 지원 방식이 다르다
    - 오라클은 시퀀스를 제공, MySQL은 그렇지 않다
    - 대신 MySQL은 AUTO_INCREMENT 기능을 제공
- 키 생성 전략을 사용하려면, `hibernate.id.new_generator_mappings=true` 추가(해야만 하는가?)
    - Hibernate 5.x 버전부터 default가 false → true로 변경되었다

### 기본 키 생성 전략 - 세부

- IDENTITY
    - 최적화
        - 데이터를 DB에 insert한 뒤에 PK값을 조회할 수 있다
        - 따라서 JPA는 추가로 DB를 조회해야 하는데, JDBC3에 추가된 Statement.getGeneratedKeys()를 사용해, 데이터를 저장하면서 동시에 생성된 PK값도 얻어 올 수 있다
        - Hibernate는 이 메서드를 사용해 DB와 한번만 통신한다
    - 트랜잭션을 지원하는 쓰기 지연 동작 X
        - 본 전략은 엔티티를 DB에 저장해야 식별자값을 구할수있으므로, em.persist()를 호출하는 즉시 insert 쿼리가 DB에 전달된다. 따라서 이 전략은 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다
- SEQUENCE
    - SequenceGenerator.allocationSize의 기본값이 50인것에 주의
    - JPA는 시퀀스에 접근하는 횟수를 줄이기 위해, 해당 사이즈 값을 사용하는데, 설정 값만큼 시퀀스 값을 한번에 증가시키고 그만큼 메모리에서 시퀀스 값을 할당한다
    - 여러 JVM이 동시에 동작해도 PK값이 충돌나지 않는 장점이 있는 반면, DB에 직접 접근해 데이터를 등록할때 시퀀스값이 한번에 증가함을 주의해야 한다
- TABLE
- AUTO
    - 자동 생성 3가지 방법 중 하나를 자동으로 선택한다
    - 오라클 - SEQUENCE
    - MySQL - IDENTITY
        - Hibernate 5부터 MySQL에서의 GenerationType.AUTO는 IDENTITY가 아닌 TABLE을 기본 시퀀스 전략으로 가져간다
        - [https://jojoldu.tistory.com/295](https://jojoldu.tistory.com/295)
    - DB를 변경해도 코드 수정이 없는 장점이 있고, 키 생성 전략이 확정되지 않은 개발 초기에 유용

- 권장하는 식별자 선택 전략 - 자연키보단 대리키를 권장
    - 현실과 비즈니스 환경은 생각보다 쉽게 변한다. 심지어 주민등록번호라도
    - 외부 풍파에 흔들리지 않는 대리키를 일반적으로 추천

### 필드와 컬럼 매핑 : 레퍼런스

- 필요할 때 책 찾아보기
- @Enumerated
    - EnumType.ORDINAL vs EnumType.STRING : 장단점 존재, 후자 권장
- @Temporal
    - TemporalType.DATE/TIME/TIMESTAMP
    - 생략하면 자바 Date와 가장 유사한 timestamp로
    - 방언 : MySQL - datetime / H2, Oracle, PostgreSQL - timestamp

# 5장. 연관관계 매핑 기초

### 연관관계 매핑의 핵심 키워드

1. 방향 (단/양 방향)
2. 다중성 (다대일, 일대다, 일대일, 다대다)
3. 주인 (양방향일 경우)

### 연관관계 : 객체 vs 테이블

- 객체는 참조(주소)로 연관관계를 맺는다
- 테이블은 FK로 연관관계를 맺는다

### @JoinColumn

- 외래 키 매핑, 즉 **FK의 컬럼 명 결정**
- 생략시 기본 전략 - `필드명_참조하는테이블의PK컬럼명`

→ 아래와 같이, ManyToOne 같은 일반적인 상황이면 어노테이션을 명시하는 다쪽이 FK를 가지므로 team_id나 group_no처럼 주면 된다. 하지만, OneToMany단방향같은 특수상황에서 조금 헷깔리는데, 일대다는 반대편이 FK를 가지므로, `필드명_` 으로 시작하지않고 어노테이션을 명시하는 `해당 클래스_pk명` 처럼 해야한다.

→ 따라서 JoinColumn(name = "???")의 값을 채울때, 어쩔땐 필드(상대편)를 기준으로 어쩔땐 자기클래스(본인)를 기준으로 해서 헷깔릴수있음.

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%204.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%204.png)

→ 이상하게 grp_on으로 네이밍해도 잘 됨

- 보통은 위의 경우, `@JoinColumn(name = "group_no")` **으로 명시할 것.
- 물론 group_no이면 기본전략과 같기 때문에 생략해도 group_no로 생성되는건 같음.

### 양방향 : 연관관계의 주인 & mappedBy

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%205.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%205.png)

- **주인 : FK를 갖고 관리하는 엔티티**
- **mappedBy : 주인은 사용하지 않음. 하인이 본 속성을 사용해, `주인 엔티티의 하인 필드명`으로 주인을 설정한다.**
- 배경

    양방향 매핑을 하면, 객체의 연관관계를 관리하는 포인트가 2곳이 된다. 객체의 참조는 둘인데 외래키는 하나다. 이러한 차이로 인해, JPA는 둘 중 하나를 정해 FK를 관리하게 하는데, 이를 연관관계의 주인이라고 한다.

- 특징

    다대일, 일대다의 관계에선 항상 다 쪽이 FK를 가지며 주인이다.

- 기준

    연관관계의 주인은 FK의 위치를 고려해 정해야지, 비즈니스 중요도로 접근하면 안된다.

### 주의 - 연관된 엔티티 삭제

기존의 연관관계를 먼저 제거하고 엔티티를 삭제해야 한다.

```java
member.setTeam(null);
em.remove(team);
```

### 주의 - 양방향에서 한쪽에만 저장

`team.getMembers().add(member);`

하인쪽에만 데이터를 저장하면 제대로 저장되지 않는다. (주인만 FK를 갖고 관리할 수 있으니까)

그렇다면, 주인에만 저장해도 될까?

```java
Team team = new Team("woowa");
em.persist(team);

Member member = new Member("sean");
member.setTeam(team);
em.persist(member);

em.flush(); // flush안하면 sean 출력되지 않음
em.clear();

Team findTeam = em.find(Team.class, team.getId());
System.out.println(findTeam.getMembers()); // sean 출력
```

Flush하거나 Cascade 옵션을 걸면, 부모저장시 자식까지 자동으로 저장된다. (되긴 된다는 것)

하지만 **객체 관점에서 양쪽 모두에 저장해주는게 안전하다.**

JPA를 사용하지 않는, 순수한 객체 상태에서 문제가 될 수 있기 때문.

```java
member.setTeam(team);
team.getMembers().add(member); // 하인쪽에도 해주자
```

*(이렇게 신경쓸거리가 늘기 때문에, 양방향이 더더욱 귀찮기도 함)*

→ 위의 코드는 실수로 둘중 하나를 빼먹을 가능성이 높다. 두 코드를 하나로 만들어서 안전하게 사용하자

```java
public void setTeam(Team team) {
	this.team = team;
	team.getMembers().add(this);
}
```

→ 하지만 여전히 작은 버그가 있다. 

```java
member.setTeam(team1);
member.setTeam(team2);
Member findMember = team1.getMember(); // 여전히 member가 조회된다
```

→ 사실 DB에서 FK는 Member가 갖고있어서 team2를 참조하도록 정상적으로 반영되어있다. 또한 새로운 영속성 컨텍스트에서 team1.getMember() 를 다시 조회하면, 관계가 끊어져있으므로 조회되지않는다.

→ 하지만 기존 영속성 컨텍스트내라면 member가 조회되는 문제가 발생하므로, 관계를 제거해주는 것이 안전하다

```java
public void setTeam(Team team) {
	if (this.team != null) {
		this.team.getMembers().remove(this);
	}

	this.team = team;
	team.getMembers().add(this);
}
```

### 양방향은 신중히 사용하자

사실 양방향의 장점은 반대방향으로 객체 그래프 탐색 기능이 추가된 것 뿐이다.

단방향 매핑만으로도, 테이블과 객체의 매핑은 이미 완료되었기 때문이다.

따라서 오히려 단점이 더 클 수 도 있으니, 양방향은 신중히 사용하자.

# 6장. 다양한 연관관계 매핑

### 일대다 단방향

- 특징

    특이하게, 반대편 테이블이 FK를 관리한다

- 주의

    일대다 단방향 관계에선, @JoinColumn을 명시해야 한다. 그렇지 않으면 JPA는 중간의 연결 테이블을 만들어 관리(하는 조인테이블 전략을 기본으로)한다.

- 단점

    외래키가 다른 테이블에 있어, 쿼리를 추가로 보내야 한다.

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%206.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%206.png)

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%207.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%207.png)

- 일대다 단방향을 쓸거면, 차라리 (다대일까지) 양방향을 사용하자

### 일대일

1. 주 테이블에 FK
    - FK를 객체 참조처럼 쓸수있어, OOP 개발자들이 선호하는 방식
    - 주 테이블만 확인해도 대상 테이블과 연관관계 여부를 알 수 있다
2. 대상 테이블에 FK
    - 전통 DB 개발자들이 선호하는 방식
    - 일대일→일대다로 변경시, 테이블 구조를 그대로 유지할 수 있다
    - JPA에서 단방향은 불가능하다. 본 방식을 사용하려면 양방향 매핑

### 다대다

- @JoinTable
    - 중간의 연결 테이블을 매핑
    - 다대다 관계에서 본 어노테이션을 통해, 연결 테이블의 속성을 설정할 수 있다. 하지만 연결 테이블의 관리가 힘들고 컬럼을 추가할 수 도 없기 때문에, 별도의 중간 엔티티를 만드는 방식이 주로 사용됨
- 중간을 연결하는 엔티티
    - A -* B *- C (일대다-다대일 구조)

# 7장. 고급 매핑

### 상속 관계 매핑

슈퍼-서브타입 논리 모델을, 실제 물리 모델인 테이블로 구현하는 3가지 방법

1. 조인 전략, Joined Strategy

    엔티티 각각 테이블로 만들고, 자식이 부모의 PK를 받아서 PK&FK로 사용하는 방식

2. 단일 테이블 전략, Single-Table Strategy

    테이블을 하나만 사용하는 방식.

    구분컬럼으로 어떤 자식 데이터인지 구분하며, 모든 자식 컬럼은 nullable

3. 구현 클래스마다 테이블 전략, Table-per-Concrete-Class-Strategy

    자식 엔티티마다 테이블을 만드는 방식, 추천하지 않는 방식

→ 3가지 방식 모두, 각자의 장단점과 특징이 있다. 더 자세한 내용은 필요할 때 찾아보기

### @MappedSuperclass

- 추상 클래스 같은 느낌으로, @Entity와 달리 실제 테이블로 매핑되지 않고, 단순히 매핑 정보를 상속할 목적으로만 사용된다
- 대표적인 사용 예시로 BaseEntity
- 특징
    - 엔티티가 아니므로 em.find()나 JPQL에서 사용불가
    - 이 클래스를 직접 생성해 사용할 일은 거의 없으므로, 추상 클래스로 만드는 것을 권장

### 복합키 매핑 & 식별/비식별 관계 매핑

- 관계 종류
    - 식별 관계 - 부모 테이블의 PK를 받아, 자식 테이블이 PK&FK로 사용하는 관계
    - 비식별 관계 - 부모 테이블의 PK를 받아, 자식 테이블이 FK로만 사용하는 관계
        - 필수적 비식별 관계 - FK에 null 허용X, 연관관계 필수
        - 선택적 비식별 관계 - FK에 null 허용, 연관관계 필수X
- 복합키

    식별자 필드가 2개 이상이면, 별도의 식별자 클래스를 만들어야 한다.

    1. `@IdClass`
        - RDB에 가까운 방법
        - 식별자 클래스의 조건
            - 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야 함
            - Serializable 인터페이스를 구현해야 함
            - equals, hashcode를 구현해야 함
            - 기본 생성자가 있어야 함
            - Public 클래스여야 함
    2. `@EmbeddedId`
        - OOP에 가까운 방법
        - 식별자 클래스의 조건
            - @Embbedable 어노테이션을 붙여야 함
            - Serializable 인터페이스를 구현해야 함
            - equals, hashcode를 구현해야 함
            - 기본 생성자가 있어야 함
            - Public 클래스여야 함
- `@MapsId`
    - 아래 예제에서, Dependent 클래스는 DependentId 라는 복합키를 PK로 가지는데, 이 중 일부(empid)(value 생략하면 전체)를 상대 연관 엔티티(Employee)와의 FK로 매핑하려는 경우
    - 결국, Employee~Dependent 연관관계에서 FK(Employee의 pk인 long empId 컬럼에 매핑되는)는 Dependent 쪽에 있고, 그 FK로서 EmbeddedId의 일부 혹은 전체를 사용하겠다는 것

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%208.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%208.png)

- 결론 : 식별 관계보다는 비식별 관계를 선호한다
    - 식별 관계에선 부모의 PK가 자식으로 전파되며 컬럼이 점점 많아진다. 조인할 때 SQL도 복잡해지고, PK 인덱스도 불필요하게 커질 수 있음
    - 식별 관계의 경우, PK로 비즈니스 의미가 있는 자연키 컬럼을 조합하는 경우가 많다. 이전에 언급한대로, 비즈니스 요구사항과 무관한 비식별 관계의 대리키 방식이 더 안정적이다
    - 부모와 자식이 결합되있어, 테이블 구조도 유연하지 않음
    - 복합키 클래스를 비롯한 수고가, 대리키를 쓰면 훨씬 편하다

    → 물론, "기본키 인덱스를 활용하기 좋고, 특정 상황에서 조인없이 하위테이블만으로 검색이 가능하다"는 식별 관계의 장점도 있다. 상황에 맞게 활용하되, 기본적으로 "비식별 관계 + Long타입 대리키 사용"을 권장

### Tip - PK 타입으로 long(원시 타입)이 아닌 Long(래퍼 타입)이 자주 쓰이는 이유

- 원시 타입이면 별도로 데이터를 저장하지 않았을 때, 0으로 초기화 되어, 초기화된 0인지 비즈니스적 의미를 갖는 0인지 헷깔린다
- 따라서 래퍼 타입으로 null 초기화 시키는 게 낫다

### 연관관계를 설계하는 2가지 방법 : @JoinColumn & @JoinTable

기본적으로 조인 컬럼을 이용, 필요한 경우 조인 테이블 이용

### 엔티티 하나에 여러 테이블 매핑 : @SecondaryTable

권장하지 않는 방식.

테이블 당 각각 엔티티를 만들어 일대일 매핑하는 것을 권장

항상 두 테이블을 조회해 최적화하기 어렵다. 일대일 매핑은 원하는 부분만 조회할 수 있고, 필요할 때 둘 다 조회하면 된다.

# 8장. 프록시와 연관관계 관리

### 지연 로딩의 구현 : 프록시

- JPA 표준 명세는 지연 로딩의 구현을 JPA 구현체에 위임했다.
- Hibernate는 2가지 방법을 제공하는데, 프록시를 사용하는 방법과 바이트코드를 수정하는 방법이다.
- 결론 : 지연 로딩을 위해선 가짜 객체가 필요하다. 이때 프록시 객체가 사용된다.

### 프록시 기초

- 기본적인 목적 ← 뒤에서 나오지만 꼭 그런건 아님
    - `em.find()` - 엔티티 객체 리턴
    - `em.getReference()` - 프록시 객체 리턴 (DB 조회X, 실제 엔티티 생성X)
- 프록시 구조 & 위임
    - 프록시는 실제 클래스를 상속받아 만들어져 겉 모양이 같다. 따라서 사용하는 입장에서 구분하지 않아도 된다.
    - 프록시는 실제 객체에 대한 참조를 보관한다. 이를 통해, 프록시의 메소드를 호출하면 실제 객체의 메소드를 호출(위임)한다.

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%209.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%209.png)

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2010.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2010.png)

- 프록시 초기화
    - member.getName() 처럼 실제 사용될 때, DB 조회해 실제 엔티티 객체를 생성한다. (프록시 초기화)

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2011.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2011.png)

### 프록시의 특징

- 프록시 객체는 처음 사용될 때 한번만 초기화된다
- 프록시 객체를 초기화한다고 프록시가 실제 엔티티로 바뀌는 건 아니다. 프록시를 통해서 실제 엔티티에 접근할 수 있는 것
- 프록시 객체는 원본 엔티티를 상속받은 객체이므로, 타입 체크 시 주의해야 한다
    - 타입 비교 시, ==보다 instanceof 사용
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 DB를 조회할 필요가 없으므로, em.getReference()를 호출해도 프록시가 아닌 실제 엔티티를 반환한다
    - 이유 1 - 찾는 엔티티가 이미 영속성 컨텍스트에 있으니까
    - 이유 2 - 같은 한 Tx 안에선 동일성(==이 true 나오도록)을 보장해주려는 JPA의 메커니즘&노력...!
    - 반대도 마찬가지
        - em.getReference() 후에 em.find() 하면 프록시가 나온다
- 프록시의 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 따라서 영속성 컨텍스트의 영향 밖인 준영속 상태의 프록시를 초기화하면 문제가 발생한다. Hibernate는 `org.hibernate.LazyInitializationException` 발생
    - *무조건 한번 이상 만나게 될 예외*
    - 예를 들면, Tx(영속성 컨텍스트)가 끝난 후 member.getName() 하면 예외 발생 가능

### 프록시 추가 내용

- `PersistenceUnitUtil.isLoaded(Object entity)` - 프록시 인스턴스의 초기화 여부 확인 가능
- `object.getClass` - 조회한 엔티티가 진짜 엔티티인지 프록시인지 확인 가능
- 프록시 강제 초기화 - `Hibernate.initialize(object)`
    - JPA 표준에는 프록시 강제 초기화 메소드가 없어, member.getName() 처럼 직접 호출해야 함

### 즉시 로딩과 지연 로딩

- 즉시 로딩
    - FetchType.EAGER
    - 엔티티를 조회할 때 연관 엔티티도 함께 조회
    - JPA 구현체는 보통 조인 쿼리를 사용
    - 기본 설정 - 일대일, 다대일 (FooToBoo 에서 상대쪽 Boo에 따라 결정되는 것으로 이해하면 직관적)
- 지연 로딩
    - FetchType.LAZY
    - 연관 엔티티를 실제 사용할 때 조회
    - 기본 설정 - 일대다, 다대다

### NULL 제약조건과 조인 전략

- @JoinColumn(nullable = true) - 기본값, null 허용, 외부 조인 사용
- @JoinColumn(nullable = false) - null 허용X, 내부 조인 사용
- 또는 @ManyToOne(optional = false) 도 내부 조인을 사용한다
- *내부 조인이 외부 조인보다 성능과 최적화 면에서 유리하긴 함*

### Collection Wrapper, 컬렉션 래퍼

- 엔티티를 프록시 객체가 지연 로딩한다면, 컬렉션은 컬렉션 래퍼가 지연 로딩한다
    - member.getOrders() → 컬렉션 초기화 X
    - member.getOrders().get(0) → (실제 데이터 조회할 때) DB 조회 및 초기화 O
- Hibernate는 엔티티를 영속 상태로 만들 때, 엔티티에 컬렉션이 있으면 컬렉션을 관리할 목적으로, 원본 컬렉션을 Hibernate가 제공하는 내장 컬렉션으로 변경한다
- *컬렉션 래퍼도 컬렉션에 대한 프록시 역할을 하는 것이므로, 굳이 구분할 필요는 없고 똑같이 프록시로 불러도 된다*

### 주의점 - 기본 설정과 달리, 모든 연관관계에 지연 로딩하는 것을 권장

- 꼭 필요한 곳에만 즉시 로딩한다

### 주의점 - 컬렉션(~ToMany)에 FetchType.EAGER 사용하는 경우, 2가지 주의

1. 컬렉션을 2개 이상 즉시 로딩하는 것은 권장되지 않는다
    - N x M 의 결과로 반환될 수 있다. 물론 성능도 저하
    - 그래서 QueryDsl 에서 OneToMany 2개 이상 패치조인하면 .distinct 걸어줘야 했던 것
2. 외부 조인을 사용해야 한다
    - Member가 한 명도 없는 Team을 내부 조인해서 가져오면, Team 까지 조회되지 않을 수 있다 (다시 말하면, Team을 가져오면서 내부 조인으로 Members 컬렉션을 함께 가져오는데, 멤버가 한명도 없는 경우)

### 주의점 - 즉시로딩은 JPQL에서 N+1을 유발하기 쉽다 (무조건 발생시키는건 아님)

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2012.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2012.png)

예상외로, 위의 주석처럼 Member가 Team까지 eager로 가져오지 않고, 쿼리를 2번 따로 보낸다.

JPA에서, JPQL은 그대로 SQL로 번역되어 실행되고, Member를 가져와봤더니 Team 연관관계가 있어서 다시 쿼리를 보내 가져왔기 때문.

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2013.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2013.png)

해결책 - 패치 조인 걸면, N+1 나지 않는다.

### 영속성 전이 : Cascade

- 오해
    - 즉시/지연 로딩, 연관관계 등 앞의 내용과 전혀 관계없이 별개다
    - 단지 엔티티를 영속화할 때, 연관된 엔티티도 함께 영속화하는 편리함을 제공해 줄 뿐이다
- 쉽게 설명하면, 부모 엔티티를 저장/삭제/... 할 때 자식 엔티티도 함께 ~하는 것
- 종류 - ALL, PERSIST, MERGE, REMOVE, REFRESH, DETACH

- 영속성 전이 - 삭제
    - 원래는 자식 먼저 삭제하고 부모를 삭제해야 한다
        - (Cascade 없이) 부모를 먼저 삭제하면, FK 제약조건으로 예외 발생
    - 이때, CascadeType.REMOVE를 걸면 부모만 삭제해도 연관된 자식도 자동으로 삭제 된다

### 고아 객체, orphanRemoval

- 부모 엔티티와 연관관계가 끊어진 자식 엔티티(고아 객체)를 자동으로 삭제하는 기능
- Ex - parent.getChildren().remove(0) 이나 parent.getChildren().clear() 처럼, 부모에서 자식 참조를 제거하면, 자식 엔티티가 자동으로 삭제 된다
- Ex - 부모를 제거하면 자식은 고아가 되므로 자식도 제거 (CascadeType.REMOVE와 같은 효과)
- 특징
    - 참조하는 곳이 하나일 때, 즉 특정 엔티티가 개인 소유하는 엔티티에만 이 기능을 사용해야 한다
    - 따라서 당연히 일대일, 일대다에만 사용 가능하다

# 9장. 값 타입

### JPA의 데이터 타입 분류

- 엔티티 타입
- 값 타입
    1. 기본값 타입
    2. 임베디드 타입 (복합 값)
    3. 컬렉션 값 타입
    - 모든 값 타입은 엔티티의 생명주기에 의존한다

### 임베디드 타입과 특징

- 임베디드 타입을 사용하기 전과, 후의 테이블은 같다. 다만 더 객체지향적으로 코드를 짤 수 있다
- 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많다. 그렇지 않은 경우, 보통 테이블과 객체를 1:1로 매핑한다
- 임베디드 타입은 값 타입은 물론, 엔티티도 참조할(가질) 수 있다
- `@AttributeOverride` - 매핑정보 재정의 (너무 많이 사용하면 코드가 더러워짐)

### 값 타입과 불변 객체

- 값 타입을 여러 엔티티에서 공유하면 위험하다. 같은 인스턴스를 참조하기 때문
- SideEffect을 막기 위해선 값을 복사해서 사용해야 한다

```java
member1.setAddress(new Address());

Address newAddress = member1.getAddress().clone();

//member2.setAddress(member1.getAddress());
member2.setAddress(newAddress);
```

- 여기서 이 이야기를 하고 있는 이유는, 자바 기본 타입은 기본적으로 값을 복사하기 때문에, 우리가 직접 만든 임베디드 값과 경우 특히 주의 해야 하기 때문에
- 항상 인스턴스를 복사해서 대입하면 공유 참조를 피할 수 있다. 하지만 항상이란건 없고 결국 실수의 가능성이 존재한다
- 해결책은 값 타입을 불변 객체로 설계하는 것이다. 객체를 불변하게 만들면, 값을 수정할 수 없으므로 부작용 걱정 없이 사용할 수 있다
- 불변 객체를 구현하는 가장 간단한 방법은 생성자로만 값을 할당하고 setter를 만들지 않는 것이다

- 동일성(==)과 동등성(equals)의 개념이 있다. 값 타입을 비교할 땐, 동등성 비교를 해야 한다. 물론 equals&hashcode를 재정의해야 한다

### 값 타입 Collection

- RDM는 당연히 컬럼안에 컬렉션은 가질 수 없고, 별도의 테이블을 추가해야 한다.
- `@ElementCollection`
- `@CollectionTable`
    - 생략시 기본값 : 엔티티이름_컬렉션속성이름 (ex. Member.address → Member_address)
- 컬렉션 값만 저장하고 엔티티를 영속화하면 자동으로 함께 저장된다 → 값 타입 컬렉션은 영속성 전이(Cascade)와 고아 객체 제거(Orphan Remove)를 기본으로 가진다고 볼 수 있다
- 값 타입 컬렉션도 FetchType을 설정할 수 있고, 기본적으로 Lazy다

### 값 타입 컬렉션의 제약사항

- 값 타입 컬렉션의 단점
    - 엔티티는 식별자가 있으므로 데이터를 추적할 수 있지만, 값 타입은 어렵다
    - **컬렉션에 변경이 있을 때, "모든" 데이터를 삭제하고 다시 저장한다** (매우 비효율적 !)
- 따라서 데이터가 많거나 실무라면, **값 타입 컬렉션 대신 일대다 관계의 엔티티를 권장**한다
    - 이 경우, 일반적으로 Cascade와 Orphan Removal이 거의 함께 사용된다
- 참고 자료

    [http://redutan.github.io/2018/05/29/ddd-values-on-jpa](http://redutan.github.io/2018/05/29/ddd-values-on-jpa)

    → 값 타입 컬렉션 역할의 일대다 엔티티를 좀 더 멋지게 이용할 수 있는 방법

    [https://homoefficio.github.io/2019/04/28/JPA-일대다-단방향-매핑-잘못-사용하면-벌어지는-일/](https://homoefficio.github.io/2019/04/28/JPA-%EC%9D%BC%EB%8C%80%EB%8B%A4-%EB%8B%A8%EB%B0%A9%ED%96%A5-%EB%A7%A4%ED%95%91-%EC%9E%98%EB%AA%BB-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EB%B2%8C%EC%96%B4%EC%A7%80%EB%8A%94-%EC%9D%BC/)

    → 일대다 단방향 매핑시 주의할 점

### 엔티티 타입 vs 값 타입의 특징

- 엔티티 타입
    - 식별자(@Id)가 있다
    - 생명 주기가 있다 (생성, 삭제, 영속화 등)
    - 공유할 수 있다
- 값 타입
    - 식별자가 없다
    - 생명 주기를 엔티티에 의존한다
    - 공유하지 않는 것이 안전하다
        - 값을 복사하거나 불변 객체로 만드는 것이 좋고, 오직 한 주인만이 관리해야 한다

→ 값 타입은 정말 값 타입이라고 생각될 때만 사용해야 한다. 식별자가 필요하고 지속적으로 값을 추적/구분/변경 해야 한다면, 그것은 값 타입이 아닌 엔티티다.

# 10장. 객체지향 쿼리 언어

### JPQL : 객체지향 쿼리 언어

- 배경
    - em.find()나 A.getB()보단 좀더 복잡한 검색 방법이 필요하다
- SQL vs JPQL
    - SQL - DB 테이블 대상의 데이터 중심 쿼리
    - JPQL - Entity 객체 대상의 객체지향 쿼리
- **종류**
    - JPA 공식 지원
        - `JPQL`
        - `Criteria` - JPQL을 쉽게 해주는 API, 빌더 클래스 모음
        - `Native SQL` - JPA에서 JPQL 대신 SQL 직접 사용 가능
    - JPA 공식 지원X
        - `QueryDSL` - Criteria보다 좀더 편함, 비표준 오픈소스 프레임워크
        - `MyBatis 같은 SQL Mapper 프레임워크`, `JDBC` 직접 사용

    → Criteria나 QueryDSL은 결국 JPQL을 편하게 돕는 기술이다

- JPQL은
    - 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리
    - SQL을 추상화해서 특정 DB SQL에 의존하지 않는다
    - *JPQL을 사용하면, JPA는 JPQL을 분석해 적절한 SQL을 만들어 DB를 조회한다*
- JPQL 특징 (뒤에서 설명)
    - JPQL은 항상 DB를 조회
    - JPQL로 조회한 엔티티는 영속 상태
    - 영속성 컨텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환

### Criteria

- JPQL을 생성하는 빌더 클래스
- 장점
    - String이 아닌 코드로 쿼리를 작성할 수 있다 (타입-세이프)
        - SQL은 오류가 있는 상태로 컴파일에 성공하고 서버에 배포될 수 있다. 이 경우, 쿼리가 실행되는 런타임에 오류가 발생한다는 점이 문제가 된다.
        - 코드로 쿼리를 작성하면, 컴파일 시점에 오류를 파악할 수 있다.
    - IDE 자동 완성도 편하다
    - 동적 쿼리를 작성하기 편하다
- 단점
    - 앞의 모든 장점을 상쇄할 정도로, 복잡하고 장황하다. 가독성도 좋지 않다.

### QueryDSL

- Criteria와 같은 JPQL 빌더 역할이나, 보다 편하고 가독성도 좋다.
- Annotation Processor를 사용해 전용 클래스를 만들어야 한다 (ex. QMember.class)

### Native SQL

- JPA에서 SQL을 직접 사용할 수 있는 기술
- 가끔은 특정 DB에 의존하는 기능을 개발해야 할 때도 있다.

### MyBatis 같은 SQL Mapper 프레임워크, JDBC 직접 사용

- JPA와 함께 사용할 경우, 영속성 컨텍스트를 적절한 시점에 강제로 플러시 해야 한다 !
    - MyBatis 같은 SQL Mapper 프레임워크나 JDBC 직접 사용하는 경우는 JPA를 우회해서 DB에 접근하기 때문에, JPQ가 인식하지 못한다.
    - 데이터 무결성을 훼손할 수 있다.
- 해결법은 JPA를 우회해서 SQL을 실행하기 전에 영속성 컨텍스트를 수동으로 플러시해서 DB와 영속성 컨텍스트를 동기화하면 된다.
    - 스프링을 쓴다면 JPA와 MyBatis를 쉽게 통합할 수 있으며
    - 스프링의 AOP를 활용해, JPA를 우회해 DB에 접근하는 메소드에 접근할 때 마다, 영속성 컨텍스트를 플러시 할 수 있다.

### JPQL 세부 사항

- 문법
    - select, from 같은 키워드는 대소문자를 구분하지 않는 반면, 엔티티와 속성은 구분한다
    - JPQL의 Member는 클래스명이 아닌 엔티티명이다. 하지만 보통 기본값인 클래스명을 엔티티명으로 쓴다
- TypeQuery, Query 객체
    - 반환 타입이 명확하면 TypeQuery 객체를 사용
    - query.getResultList()처럼 결과 조회
- 파라미터 바인딩
    - 위치 기준 파라미터 바인딩만 지원하는 JDBC와 다르게, 이름 기준 파라미터 바인딩도 지원한다.
    - 이름 기준 바인딩 방식이 더 권장된다.
        - 더 명확하고 SQL 인젝션 공격도 방지하며, 쿼리를 재사용할 수 있어 성능도 향상된다
- `Projection, 프로젝션`
    - select절에 조회할 대상을 지정하는 것
    - 엔티티와 달리 임베디드 타입은 조회의 시작점이 될 수 없는데, 이유는 임베디드 타입은 영속성 컨텍스트에서 관리되지 않기 때문
- `Paging API`
    - DB마다 페이징 SQL 문법이 달라서, JPA는 이를 추상화
    - 실무에서 페이징 SQL을 더 최적화 하려면, JPA의 Paging API 보다 Native SQL 사용

### JPQL 조인

- 내부 조인, (INNER) JOIN
- 외부 조인, LEFT (OUTER) JOIN
- 기타 조인들
    - 컬렉션 조인 - 일대다, 대다대 처럼 컬렉션을 조인하는 경우
    - 세타 조인 - 전혀 관계없는 엔티티 조인 ← 당연히 안쓰겠지
    - JOIN ON 절
- 페치 조인

    → *내부/외부 조인과 동등 범주는 아니고, SQL의 내부/외부 조인 개념을 JPQL의 페치 조인 기술로 사용하는 것 같다*

    - SQL의 조인의 종류는 아니고, JPQL에서 성능 최적화를 위해 제공하는 기능.
    - 문법 - [ left (outer) | (inner) ] join fetch
    - 연관 엔티티나 컬렉션을 한번에 조회. 일대다는 결과가 증가할 수 있음. 일대일, 다대일은 그대로.
    - 페치 조인과 distinct
        - ***JPQL의 DISTINCT는 SQL 뿐만 아니라 애플리케이션에서도 한번 더 중복을 제거***
    - 페치 조인과 일반 조인의 차이
        - JPQL은 연관관계까지 고려하지 않는다. 단지 SELECT절에 지정한 엔티티만 조회한다
        - 따라서 페치 조인을 통해, SQL 한번으로 연관 엔티티를 한번에 조회하면 성능 향상 가능
    - Best Practice - 지연 로딩을 기본적으로 쓰고, 필요한 경우 페치 조인으로 가져오는 게 효과적
    - 페치 조인의 한계
        - 페치 조인 대상에는 별칭을 줄 수 없다. JPA는 안되지만 Hibernate 등 일부 구현체는 가능
        - 둘 이상의 컬렉션을 페치할 수 없다. Cartesian 곱이 만들어진다.
        - 컬렉션 페치 조인하면, Paging API 사용 불가
            - Hibernate에서 하면, 되긴 하겠지만 메모리에서 페이징 처리를 하는 것으로, 데이터가 많을 경우 성능과 메모리 초과 이슈가 있음

    ![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2014.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2014.png)

### JPQL 동적 쿼리 vs 정적 쿼리(Named Query)

- 동적 쿼리
    - 평소에 쓰는 것
    - JPQL로 문자를 완성해 넘기는 것, 런타임시 특정 조건에 따라 JPQL을 동적으로 구성
- 정적 쿼리
    - `@NamedQuery`
    - 미리 정의한 쿼리에 이름을 부여해서 사용, 한번 정의하면 변경 불가
    - 애플리케이션 로딩 시점에 JPQL 문법을 체크하고 미리 파싱해둬, 빠른 오류 확인이 가능하며 파싱 결과를 재사용해 성능 이점도 있다. 또 변하지 않는 정적 SQL이 생기므로 DB 조회 성능 최적화에도 도움된다.

### QueryDSL 세부 사항

- 조인
    - innerJoin, leftJoin, rightJoin, fullJoin을 사용할 수 있고, 추가로 JPQL의 on과 fetch조인(성능 최적화)도 가능
- 서브 쿼리 - new JPASubQuery()
- 프로젝션
    - 조회 대상으로 여러 필드를 선택하면, 기본적으로 Map과 비슷한 com.mysema.query.Tuple 타입을 사용
    - 객체로 받을 수 도 있음
- QueryDSL도 수정, 삭제같은 배치 쿼리를 지원하지만 안 쓸 것 같다.
- 동적쿼리
    - com.mysema.query.`BooleanBuilder`

### Native SQL

- JPQL은 특정 DB에 종속적인 다음과 같은 기능들은 지원하지 않는다
    - DB 종속 함수, 문법, SQL 쿼리 힌트
    - 인라인 뷰, UNION, INTERSECT
    - Stored Procedure
- JPA의 Native SQL vs JDBC API 직접 사용
    - 엔티티를 조회할 수 있다
    - JPA의 영속성 컨텍스트의 기능을 사용할 수 있다

### 주의 - 벌크 연산

- 지원한다. 다만 같은 작업을 여러 대상에 하는 일괄적인 적용이지, 정말 다수의 데이터를 한번에 bulk insert한다던가 그런 기능은 되지 않는 듯
- 벌크 연산도 영속성 컨텍스트를 무시하고 직접 DB에 쿼리함을 주의하자
    - 해결법
        - em.refresh()
        - 벌크 연산 먼저 실행
        - 벌크 연산 수행 후, 영속성 컨텍스트 초기화

### 주의 - JPQL 조회 엔티티와 영속성 컨텍스트

- JPQL로 DB에서 조회한 엔티티가 영속성 컨텍스트에 있으면, 조회한 결과를 버리고 영속성 컨텍스트의 엔티티를 반환한다
- 왜? → 영속성 컨텍스트에 수정 중인 데이터가 사라질 수 있기 때문
- 따라서 JPQL 실행전 영속성 컨텍스트와 DB를 동기화하기 위해 플러시한다 (플러시 모드를 건들지 않으면)

### 주의 - find() vs JPQL

- em.find는 영속성 컨텍스트에 찾는 게 있으면 DB까지 가지않으므로 효율적이다
- 반면 JPQL은 항상 DB에 SQL을 실행해 조회한다

# 11장. 웹 애플리케이션 제작

### Hibernate 속성

- hibernate.dialect
- hibernate.show_sql
- hibernate.format_sql
- hibernate.use_sql_comments
- hibernate.id.new_generator_mappings (hibernate 5.x버전부터 true default)

### @PersistenceContext

- 순수 자바 환경에선 EntityManagerFactory에서 엔티티 매니저를 직접 생성해야 하지만, 스프링에선 컨테이너가 관리하며, 본 어노테이션을 통해 엔티티 매니저를 주입

### @Transactional

- 해당 클래스/메소드를 호출할 때 Tx를 시작하고, 종료할 때 커밋
- 예외가 발생하면 롤백
- 런타임/언체크드 예외만 롤백한다. 체크 예외도 롤백하려면 옵션으로 해당 예외를 지정해야 함 (사실 당연한거네?)

# 12장. 스프링 데이터 JPA

*알다시피 Spring Data JPA가, 앞의 em 및 manual한 작업들을 지금처럼 편하게 대부분 설정해줌*

*세부적인건 목차를 보며 필요할 때 보면 될 것 같다*

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2015.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2015.png)

→ 구현체는 `SimpleJpaRepository`

### 쿼리 메소드

1. 메소드 이름으로 쿼리 생성
2. 메소드 이름으로 JPA NamedQuery 호출
3. @Query 어노테이션을 사용해 Repository Interface에 쿼리 직접 정의

→ 하지만, 3번을 제외하면 거의 안씀. 팀바팀이겠지만, 현재는 QueryDSL 위주

### Paging, Sort

- ***반환 타입으로 Page를 사용하면, Spring Data JPA는 페이징 기능을 위해 COUNT 쿼리를 추가로 보낸다***

### 사용자 정의 Repository 구현 : ~Impl

- QueryDSL 안쓰는 Jay는 통계 쿼리 등에 만들어 쓴다고 함. 우리는 QueryDSL로 기본적으로 사용

### 어노테이션들

- EnableSpringDataWebSupport
- HandlerMethodArgumentResolver
    - PageableHandlerMethodArgumentResolver
    - SortHandlerMethodArgumentResolver

### Spring Data JPA & QueryDSL

- Spring Data JPA는 2가지 방법으로 QueryDSL을 지원
    1. QueryDslPredicateExecutor - 비추
    2. QueryDslRepositorySupport - JPAQuery 객체를 직접 생성해 쓰는게 좋음

# 13장. 웹 애플리케이션과 영속성 관리

### 스프링 컨테이너는 Tx 범위의 영속성 컨텍스트 전략이 기본

- = Tx와 영속성 컨텍스트의 생존 범위가 같다 = Tx 시작시 영컨 생성, Tx 종료시 영컨 종료
- 같은 Tx 안에서는 항상 같은 영속성 컨텍스트에 접근한다
    - 스프링 컨테이너는 스레드마다 다른 Tx를 할당한다. 영속성 컨텍스트가 다르므로 스레드-세이프

→ 변경 감지 기능이 뷰 계층에서도 동작하면, 계층간 책임이 모호해지고 데이터 변경 포인트가 넓어져 유지보수도 어렵다. 따라서 변경 감지가 뷰 계층에서 동작 하지 않는 것은 자연스럽다.

→ 준영속 상태에선 지연 로딩이 동작하지 않는다 (앞으로의 모든 원인이자 시작점)

- 시도 시 hibernate.LazyInitializationException 발생

## 준영속 상태의 지연 로딩 문제를 해결하는 방법

### 1. 뷰가 필요한 엔티티를 미리 로딩

1. 글로벌 페치 전략 수정 : Lazy → Eager
    - 단점 - 사용하지 않는 엔티티 로딩 & N+1
        - em.find는 괜찮다. 하지만 JPQL 사용시 N+1 발생
        - ***JPA는 JPQL로 SQL을 만들때 페치 전략과 연관관계를 고려하지 않는다.*** 따라서 쿼리가 추가로 날아감
            - JPQL로 SQL을 만들어 DB에서 엔티티 조회
            - 와보니 연관 엔티티가 있고 페치 전략도 즉시다
            - 영속성 컨텍스트에서 연관 연티티를 찾음. 있으면 다행이지만, 없으면 쿼리를 추가로 보냄
        - JPQL 페치 조인으로 해결 가능
2. JPQL 페치 조인
    - 쿼리 한번에 가져온다. 연관 엔티티를 이미 가져왔으므로, 페치 전략이 Lazy든 Eager든 무의미
    - 단점 - 현실적인 대안이지만, 무분별하게 사용시 뷰에 맞춘 Repository 메소드가 증가
3. 강제 초기화
    - Hibernate.initialize()
    - 단점 - 뷰가 서비스를 침범
        - 해결책 - FACADE 계층 추가
            - 단점 - 코드 작성의 부담, 서비스 위임 코드 반복

### 2. OSIV를 사용해서 엔티티를 항상 영속 상태로 유지

- 영속성 컨텍스트를 뷰까지 열어둔다.
- `과거 OSIV : 요청 당 트랜잭션`
    - 단점 - 뷰 계층이 엔티티 변경 가능
        - 막는 방법
            - 엔티티를 읽기 전용 인터페이스로 제공
            - 엔티티 래핑 - 읽기 전용 메소드만 가진 감싼 객체
            - DTO 반환 - OSIV의 장점을 못살림

        → 모두 코드 작성의 부담이 증가

    - 따라서 최근엔 거의 사용X
- `스프링 OSIV : 비즈니스 계층 트랜잭션`
    - 과정
        - 요청이 들어오면 서블릿 필터 or 스프링 인터셉터에서 영속성 컨텍스트 생성. 단 이때 트랜잭션은 시작하지 않음
        - 서비스계층에서 @Transactional을 만나면 1에서 미리 생성해둔 영속성 컨텍스트를 찾아와 Tx 시작
        - 서비스계층이 끝나면 Tx를 커밋하고 영속성 컨텍스트 플러시. 단 이때 Tx는 끝나지만 영속성 컨텍스트는 종료하지 않음
        - 컨트롤러와 뷰까지 엔티티는 영속 상태를 유지
        - 서블릿 필터 or 스프링 인터셉터로 요청이 돌아오면 영속성 컨텍스트 종료. 단 이때 플러시를 호출하지않고 바로 종료
    - 뷰 계층에서 엔티티를 수정 가능한 기존 OSIV의 단점을 보완
        - 영속성 컨텍스트는 뷰까지 열어 조회 가능하게 하면서, 트랜잭션은 비즈니스 계층으로 제한해 뷰단의 엔티티 변경을 막았으므로

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2016.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2016.png)

### OSIV 정리

- 스프링 OSIV의 특징
    - 요청이 들어올때부터 나갈때까지 같은 영속성 컨텍스트 유지. 엔티티는 요청이 끝날때까지 영속 상태 유지
    - 엔티티 수정은 트랜잭션이 있는 비즈니스 계층에서만, 뷰 계층은 지연 로딩을 포함한 조회만 가능
- 스프링 OSIV의 단점
    - 같은 영속성 컨텍스트를 여러 트랙잭션이 공유 가능 → 트랜잭션 롤백시 주의 (Ch 15.1.4)
    - ***성능 튜닝시 확인할 부분이 넓어진다***
- OSIV vs FACADE vs DTO
    - OSIV를 안쓰면, 어떤 방법이든 결국 준영속 상태가 되기전에 미리 초기화해야한다. 결국엔 코드를 더 많이 작성해야한다는 것
    - *하지만 실무에선 성능을 우선시*
- OSIV가 만능은 아니다
    - 복잡한 화면은 DTO 반환이 더 적합
- OSIV는 같은 JVM을 벗어난 원격 상황에선 사용할 수 없다
    - 클라이언트를 위해 데이터를 JSON으로 변환할 때, 엔티티를 직접 노출하거나 or DTO로 노출할 수 있다
    - 엔티티는 생각보다 자주 변경되고, JSON 변환 대상 객체로 사용하면 API도 함께 변경되며. **외부API**의 대상으로 어려워진다. 엔티티를 변경해도 완충 역할을 할 수 있는 DTO가 적합
    - 내부API는 클라이언트와 서버를 동시에 수정할 수 있어서 "실용적인 관점에서" 괜찮다고 생각
    - 주석
        - 외부 API - 타팀과의 API, 변경이 어려움
        - 내부 API - 언제든 서버와 클라이언트를 동시에 수정가능

# 14장. 컬렉션과 부가 기능

## 컬렉션 - 다양한 컬렉션과 특징

### JPA에서 컬렉션을 사용하는 방법 (대분류)

1. @OneToMany, @ManyToMany 를 이용해 관계 매핑
2. @ElementCollection 을 사용해 값 타입 보관

### Hibernate 내장 컬렉션과 특징

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2017.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2017.png)

- Collection, List - 엔티티 추가시, 중복 여부 상관없으므로 (지연 로딩된) 컬렉션을 초기화 하지 않는다
- Set - 엔티티 추가시, 중복 여부를 따져봐야 하므로 컬렉션을 초기화한다

### @OrderColumn vs @OrderBy

- `@OrderColumn`
    - DB에 순서값을 저장해, 조회할 때 사용
    - 실무에서 쓰기에 **단점**이 많다.
        - Board-Comment 예시에서, @OrderColumn 어노테이션 매핑은 Board에서 하지만 POSITION 컬럼은 Comment에 위치하므로, (일대다의 단점과 마찬가지로) Comment는 POSITION을 모르니까 일단 저장했다가 UPDATE 쿼리가 추가로 나간다.
        - (ArrayList vs LinkedList 차이같은 느낌) 리스트 데이터 변경시 많은 위치 값을 변경해야 한다. 예를 들어 2번을 삭제하면 3,4번 값을 1씩 줄이는 쿼리 2개 발생
        - DB에서 특정 리스트 데이터를 강제로 지우면 null로 유지되어, 나중에 참조할때 NPE가 발생할것
    - **개발자가 직접 순서값을 관리하거나 or `@OrderBy` 권장**
- `@OrderBy`
    - 순서용 컬럼을 만드는 @OrderColumn과 달리, DB의 order by절을 이용해 컬렉션을 정렬한다.

## 컨버터 - 엔티티의 데이터를 변환해서 DB에 저장

엔티티 데이터를 변환해서 DB에 저장한다

*→ 잘 안씀. PASS*

## 리스너 - 엔티티에서 발생한 이벤트를 처리

엔티티의 생명주기에 따른 이벤트 처리

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2018.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2018.png)

### 이벤트 적용 위치

1. 엔티티에 직접 적용
2. 별도 리스너 사용
3. 기본 리스너 사용

## 엔티티 그래프 - 엔티티를 조회할 때, 연관된 엔티티를 선택해서 함께 조회

@NamedEntityGraph, em.getEntityGraph

*→ 물론 안쓴다*

# 15장. 고급 주제와 성능 최적화

### 15장 목차

- JPA 예외 처리
- 엔티티 비교시 주의할 점과 해결
- 프록시로 발생하는 문제점들과 해결
- 성능 최적화
    - N+1
    - 읽기 전용 쿼리의 성능 최적화
    - 배치 처리
    - SQL 쿼리 히트 사용
    - 트랜잭션을 지원하는 쓰기 지연과 성능 최적화

## JPA 예외 처리

### JPA 표준 예외

1. 트랜잭션 롤백을 표시하는 예외
    - 심각한 예외라서 복구해선 안됨
2. 트랜잭션 롤백을 표시하지 않는 예외
    - 심각하지 않아, 개발자가 커밋 or 롤백 여부 판단

### 스프링과 JPA 예외

- 서비스 계층에서 JPA 예외를 사용하면 JPA에 의존하게 되므로, 스프링은 데이터 접근 계층에 대한 예외를 추상화
- `PersistenceExceptionTranslationPostProcessor`  Bean
    - @Repository를 사용한 곳에 예외 변환 AOP를 등록해, JPA 예외를 스프링이 추상화한 예외로 변환

### 주의사항 - 트랜잭션 롤백과 영속성 컨텍스트 (but 스프링의 도움)

- 트랜잭션을 롤백하는 것은 DB 반영사항을 롤백하는 것이지, 수정한 자바 객체까지 복구하지 않는다.
- 객체는 수정된 상태로 영속성 컨텍스트에 남아있으므로, 이 영속성컨텍스트를 그대로 사용하는건 위험하다.
- 따라서 스프링은 영속성 컨텍스트의 범위에 따라 전략을 가진다.
- 기본 전략인 '트랜잭션당 영속성 컨텍스트' 전략은 문제 발생시, 트랜잭션 AOP 종료 시점에 트랜잭션을 롤백하면서 영속성 컨텍스트로 함께 종료한다. 따라서 문제가 발생하지 않음
- 문제는, OSIV처럼 영속성 컨텍스트의 범위를 트랜잭션 범위보다 넓게 사용해, 여러 트랜잭션이 하나의 영속성 컨텍스트를 사용할때 발생한다.
- 하지만 이 경우도, 스프링은 영속성 컨텍스트의 범위를 트랜잭션 범위보다 넓게 설정하면, 트랜잭션 롤백시 영속성 컨텍스트를 초기화해서 문제를 예방한다 !
- 결론 - 스프링이 트랜잭션 롤백시 적절하게 영속성 컨텍스트로 초기화/종료 시켜준다. 따라서 우리는 크게 신경쓰지 않아도 됬던것 !

## 엔티티 비교

- 1차 캐시의 가장 큰 장점 - 애플리케이션 수준의 반복 가능한 읽기
    - 단순히 동등성 수준이 아닌 주소값도 같은 동일성 보장

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2019.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2019.png)

- 각각 다른 영속성 컨텍스트에서 관리되었기 때문에 둘은 다른 인스턴스

### 결론

- 동일성 비교는 같은 영속성 컨텍스트의 관리를 받는 영속 상태의 엔티티에만 적용 가능
- 그렇지 않을 때는 비즈니스 키를 이용해서 비교해야 한다

## 프록시 심화 주제

- 예전에 한번 언급했던 것들
    - em.find와 em.getReference가 상황에 맞게 반환하면서, 영속 엔티티의 동일성 보장
    - 엔티티 타입 비교시, ==말고 instanceof 사용

- 프록시 동등성 비교
    - IDE나 외부 라이브러리로 구현한 equals() 메소드로 엔티티 비교시, 비교대상이 원본 엔티티면 괜찮지만 프록시면 문제가 발생할 수 있다
    - ==대신 instanceof로 비교하는지, member.name보다 member.getName()을 사용하는지 확인하자

- 상속관계와 프록시 → PASS
    - 프록시를 부모 타입으로 조회하면 부모 타입을 기반으로 프록시가 생성되는 문제
        - instanceof 사용 불가, 하위 타입 다운캐스팅 불가
    - 해결책
        - JPQL로 대상 직접 조회 - 다형성 활용 불가
        - 프록시 벗기기 - Hibernate 기능 사용, 프록시와 원본 엔티티 동일성 비교 실패
        - 기능을 위한 별도 인터페이스 제공
        - Visitor 패턴 사용

- [TIP] - Visitor 패턴의 장단점
    - Visitor에는 visit() 메소드를 정의하고, 모든 대상 클래스를 받아들이도록 작성
    - 장점
        - 알고리즘과 객체 구조를 분리해, 구조를 수정하지 않고 새로운 동작을 추가할 수 있다
        - 새로운 기능이 필요할 때 Visitor만 추가하면 된다.
    - 단점
        - 복잡하다
        - 객체 구조가 변경되면 모든 Visitor를 수정해야 한다

## N+1

### N+1 문제란 무엇인가

- 블로그에 별도로 정리한 문서 참조

### 해결책

- 패치 조인
- Hibernate @BatchSize
    - 1+N → 1+N/x 비유
- Hibernate @Fetch(FetchMode.SUBSELECT)
    - 서브 쿼리

→ 기본적으로 지연 로딩 설정 + 필요한 곳에 패치조인 권장

## 읽기 전용 쿼리의 성능 최적화

### 배경

- 영속성 컨텍스트로 얻는 이점도 많지만, 변경 감지를 위해 스냅샷 인스턴스를 보관하는 메모리 사용의 단점도 있다.
- 예를 들어, 다수의 데이터를 한번 읽어 출력하는 상황이 있다. 조회한 엔티티를 다시 조회하거나 수정할 일도 없다.
- 이 경우, 읽기 전용을 조회하면 메모리 사용량을 최적화할 수 있다.

### 해결책

- 스칼라 타입으로 조회
    - 엔티티가 아닌 o.id, [o.nam](http://o.name)e 처럼 스칼라 타입으로 조회하면, 영속성 컨텍스트가 결과를 관리하지 않는다
- 읽기 전용 쿼리 힌트 사용
    - Hibernate 전용 힌트인 org.hibernate.readOnly를 사용할 수 있다
    - 다만, 실무 환경에서 '쿼리 힌트' 자체의 사용이 권장되진 않는 듯.
- 읽기 전용 트랜잭션 사용 `@Transactional(readOnly = true)`
    - 플러시 모드가 MANUAL로 설정되어, 트랜잭션을 커밋해도 영속성 컨텍스트를 플러시하지 않는다.
    - 플러시 할때 일어나는 무거운 동작들이 생략되어 성능 향상. 물론 트랜잭션 시작과 커밋 등은 정상적으로 일어난다. 단지 영속성 컨텍스트의 플러시만 안할 뿐.
- 트랜잭션 밖에서 읽기
    - 트랜잭션 없이 엔티티를 조회

## 배치 처리

### 배경

수천 수만건 이상의 엔티티를 한번에 등록시, 영속성 컨텍스트에 엔티티가 계속 쌓여 OOM이 발생할 수 있다. (실제로 그렇더라, 배달권역 프로젝트 경험 기억)

일정 단위로 영속성 컨텍스트를 플러시하고 초기화 해줘야 한다.

### 해결책

- DB의 Paging 기능 활용
    - JPA Paging
- DB의 CURSOR 기능 활용
    - JPA는 JDBC CURSOR를 지원하지 않아, Hibernate의 Session 사용
    - 하이버네이트는 scroll 이라는 이름으로 JDBC 커서를 지원

- [TIP] - Hibernate는 무상태 세션이라는 특별한 기능을 제공 (만날일 없을 듯?)
    - 영속성 컨텍스트를 만들지 않고, 2차 캐시도 사용하지 않음

## SQL 쿼리 힌트

- JPA는 SQL 쿼리 힌트 기능을 제공하지 않아, Hibernate 기능 사용
- But, 실무에서 힌트 사용 권장X
- (MySQL은 힌트를 맹신해서 무조건 써버리는 단점이 있다나 ?)

## 트랜잭션을 지원하는 쓰기 지연과 성능 최적화

- JPA는 플러시 기능이 있으므로, INSERT 쿼리를 모아서 한번에 보낼 수 있다
- 하지만 IDENTITY 식별자 생성 전략은, 엔티티를 DB에 저장해서 식별자를 알 수 있으므로, em.persist를 호출하는 즉시 INSERT 쿼리가 날아간다. 따라서 **쓰기 지연을 활용한 성능 최적화를 할 수 없다**. (결국 안되는 거나 마찬가지)

- 트랜잭션을 지원하는 쓰기 지연과 변경 감지 기능으로 인해
    - 성능과 개발 편의성도 얻을 수 있지만
    - 진짜 장점은 **테이블 ROW에 걸리는 Lock을 최소화할 수 있다**
    - 커밋 직전까지 락을 걸지 않으므로

# 16장. 트랜잭션과 락, 2차 캐시

## 트랜잭션과 락

### 배경

- 트랜잭션은 ACID를 보장해야 한다. 그 중에, 격리성을 완벽히 보장하려면 트랜잭션을 거의 차례로 실행해야한다. 하지만 이는 동시성 처리 성능을 매우 떨어뜨린다.
- 이로 인해, 트랜잭션 격리 수준을 4단계로 구분한다.

![%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2020.png](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20ORM%20%E1%84%91%E1%85%AD%E1%84%8C%E1%85%AE%E1%86%AB%20JPA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20(%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB)%2022d7f47d835a479988f8fd70a07b13b8/Untitled%2020.png)

→ 보통 `READ COMMITTED`를 기본으로 사용

→ *최근에는 동시성 처리를 위해 락보단 MVCC를 사용한다고 함*

### 격리 수준에 따른 문제점들

- `Dirty Read`
    - 커밋하지 않은 데이터를 읽을 수 있는 문제 (다른쪽에서 수정중인 데이터가 읽힘, 아직 커밋 안했는데도)
- `Non-Repeatable Read`
    - 반복해서 같은 데이터를 읽을 수 없는 상태 (그 사이에 다른쪽에서 데이터를 수정했을 경우)
- `Phantom Read`
    - 반복 조회시 결과 데이터가 달라짐

### 낙관적 락과 비관적 락

- 낙관적 락
    - 개념 - 트랜잭션 대부분 충돌이 발생하지 않는다고 가정
    - 원리 - JPA(애플리케이션 단의) 버전 관리 기능 사용
    - 특징
        - 대표적으로 `@Version`
        - 커밋 전까지 충돌 여부를 알 수 없다
- 비관적 락
    - 개념 - 트랜잭션 충돌이 발생한다고 가정하고, 일단 락을 걸고 보는 방법
    - 원리 - DB가 제공하는 락 기능 사용
    - 특징
        - 대표적으로 `select for update`
- `Second Lost Updates Problem`
    - 더 나아가면, DB 트랜잭션 범위를 넘어서는 문제도 있다
    - 2명이 한 데이터를 동시에 수정한다면 어떻게 할지 3가지 방법 존재
    - 처음만 인정 or 마지막만 인정 or 충돌 내용 병합
    - JPA 버전 관리 기능(Version)을 쓰면 '처음만 인정' 구현 가능

### @Version

엔티티를 수정할 때 마다, 값이 1씩 증가. 커밋 때 조회 시점의 값과 다르면 예외 발생

### JPA 락 사용

- READ COMMITTED 트랜잭션 격리 수준 + 낙관적 버전 관리 전략을 권장
- 코드상으로 락은 다음의 위치에 적용 가능
    - em.lock(), em.find(), em.refresh()
    - Query.setLockMode()
    - @NamedQuery

### JPA 낙관적 락

- @Version 사용
- 락 옵션 (더 세밀한 제어)
    - NONE
    - OPTIMISTIC
    - OPTIMISTIC_FORCE_INCREMENT

        → DDD의 Aggregate Root에 사용 가능

### JPA 비관적 락

- DB 트랙잭션 락 메커니즘에 의존
- 종류
    - PESSIMISTIC_WRITE
        - 비관적 락이라 하면 보통 이 옵션을 뜻한다
        - select for update를 사용해서 락을 건다
    - PESSIMISTIC_READ
    - PESSIMISTIC_FORCE_INCREMENT

## 2차 캐시

### 1차 캐시와 2차 캐시

- 영속성 컨텍스트 자체가 사실상 1차 캐시다
- 1차 캐시로도 이점이 많지만, 2차 캐시를 통해 DB 접근 횟수를 더 획기적으로 줄일 수 있다
- 범위
    - 1차 캐시 - 영속성 컨텍스트 범위
    - 2차 캐시 - 애플리케이션 범위 (App. 종료까지 캐시 유지)

### 2차 캐시, L2 cache = Second Level cache

- 1차 캐시가 `트랜잭션 - 1차캐시 - DB`의 그림이라면
- 2차 캐시는 `영속성컨텍스트(1차캐시)s - 2차캐시 - DB`의 그림
- 2차 캐시는 동시성을 극대화하기 위해, 캐시한 객체를 직접 반환하지 않고 복사본을 만들어 반환한다. 락에 비하면 객체를 복사하는 비용은 훨씬 저렴하다

### JPA 2차 캐시

- `@Cacheable`
    - 출처 - javax.persistence.Cacheable
    - *→ 우리 플젝 코드상에서 꽤 씀*
- `@Cache`
    - 출처 - org.hibernate.annotations.Cache
- 캐시를 무시하고 DB를 조회하거나, 캐시를 갱신하려면, 캐시 조회 모드와 캐시 보관 모드를 사용하면 된다고 함

### 외부) Hibernate & EHCACHE 활용

- 하이버네이트가 지원하는 캐시는 3 종류
    1. 엔티티 캐시
    2. 컬렉션 캐시
    3. 쿼리 캐시

    → 2, 3 은 결과 집합의 식별자만 캐시한다. 따라서 컬렉션/쿼리 캐시만 사용하고 엔티티 캐시를 안쓰면, 최악의 경우 결과 집합 수만큼 쿼리가 나갈 수 있다. 따라서 2, 3 을 쓰면 결과 대상 엔티티에는 꼭 캐시를 적용해야 한다