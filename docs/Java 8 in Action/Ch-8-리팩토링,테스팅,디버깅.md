# Ch 8. 리팩토링, 테스팅, 디버깅

Java 8 in Action :: Contents

### Preview

> - 람다식을 이용해 기존 코드를 어떻게 리팩토링 해야 하는 지
- 람다식으로 Strategy, Template method, Observer, Chain of Responsibility, Factory 등의 객체지향 디자인 패턴을 간소화 하는 법
- 람다식과 스트림 API 코드를 테스트 & 디버깅 하는 법

이 장은 특히 직접 교재의 코드를 함께 보는 것이 더 정확하게 의미를 이해할 수 있을 것 같다.

# 가독성과 유연성을 개선하는 리팩토링

---

- 익명 클래스를 람다식으로 리팩토링

    이때, 주의할 점 (모든 익명 클래스를 람다식으로 변환할 수 있는 것은 아니다 !)

    1. 익명 클래스에서의 this, super와 람다식에서는 다른 의미를 갖는다. 익명 클래스에서 this는 익명 클래스 자신을 가리키지만, 람다식에선 람다를 감싸는 클래스를 가리킨다.
    2. 익명 클래스는 감싸는 클래스의 변수를 가릴 수 있다. (shadow variable) 하지만 람다식은 가릴 수 없다.
    3. 익명 클래스를 람다식으로 바꾸면, context 오버로딩에 따른 '모호함'이 초래될 수 있다. 익명 클래스는 인스턴스화할 때 명시적으로 형식이 정해지지만, 람다는 context에 따라 달라지기 때문. 물론 람다에서도 (Task) ~~와 같이 명시적 형변환으로 모호함을 제거할 수 있긴 하다.

- 람다식을 메서드 레퍼런스로 리팩토링
    - 메서드 레퍼런스를 이용해 코드의 의도를 보다 명확하게 알릴 수 있다. (가독성)
    - comparing, maxBy같은 `정적 헬퍼 메서드`를 활용하는 것도 좋다. 이들은 method reference와 조화를 이루도록 설계되었다.

- 명령형 데이터 처리를 스트림으로 리팩토링
    - 스트림 API는 데이터 처리 파이프라인의 의도를 더 명확하게 보여준다.

        (물론 short circuit, laziness라는 최적화와 병렬성도 제공하며)

- 코드 유연성 개선 : 동작 파라미터화

    → 함수형 인터페이스 적용

    1. 조건부 연기 실행 (Conditional deferred execution)

            본문 중에서 객체의 상태가 클라이언트의 코드로 노출되고, 
            동작마다 상태 확인이 일어나야 한다는 점을 지적하는 부분이 주목할만하다.

    2. 실행 어라운드 (Execute around)

            Ch3의 processFile 예제

# 디자인 패턴 리팩토링

---

람다 표현식을 이용해 객체지향 디자인 패턴을 제거하거나 간결하게 재구현한다.

역시 본문의 코드와 함께 봐야 한다.

### 전략 (Strategy) 패턴

한 유형의 알고리즘을 보유한 상태에서 런타임에 적절한 알고리즘을 선택하는 기법

### 템플릿 (Template method) 패턴

알고리즘의 개요를 제시한 다음에 알고리즘의 일부를 고칠 수 있는 유연함을 제공해야 할 때

즉, "이 알고리즘을 사용하고 싶은데 그대로는 안 되고 조금 고쳐야 하는" 상황

### 옵저버 (Observer) 패턴

이벤트가 발생했을 때 한 객체(subject)가 다른 객체 리스트(observer)에 자동으로 알림을 보내야 하는 상황

### 의무 체인 (Chain of Responsibility) 패턴

작업처리 객체의 체인(동작 체인 등)을 만들 때

즉, 한 객체가 어떤 작업을 처리한 다음 다른 객체로 결과를 전달하고, 다른 객체도 해야 할 작업을 처리한 다음 또 다른 객체로 전달하는 방식

### 팩토리 (Factory) 패턴

인스턴스화 로직을 클라이언트에 노출하지 않고 객체를 만들 때

→ 람다식으로 디자인 패턴에서 발생하는 자잘한 코드들을 제거할 수 있다. 물론, 로직이 복잡하다면 람다식보다 기존의 클래스 구현 방식이 나을 수도 있다.

# 람다 테스팅 & 디버깅

---

- 보이는 람다식의 unit testing
- 람다를 사용하는 메서드의 동작에 집중하라
- 복잡한 람다를 개별 메서드로 분할
- 고차원 함수 테스팅

> 문제가 발생한 코드를 디버깅할 때 개발자는 다음 두 가지를 먼저 확인한다.
스택 트레이스 & 로깅

- 람다식은 이름이 없기 때문에 Stack Trace가 복잡하다. 이를 염두에 두고 알고있어야 한다.
- 그치만 메서드 레퍼런스를 사용하면, 스택 트레이스에 찍힌다.
- 스트림 파이프라인에서 요소를 처리할 땐, peek 메서드로 중간값을 확인할 수 있다.