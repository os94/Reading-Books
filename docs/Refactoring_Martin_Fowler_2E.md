# Refactoring_Martin_Fowler_2E


# Ch6 - 기본적인 리팩터링

- 함수 추출 ↔ 함수 인라인
    - 함수 네이밍은, How 가 아닌 What 을
    - 값을 반환할 변수가 여러개라면, 값들을 클래스로 묶어서 반환하기 보단, 각각을 반환하는 함수를 여러개 만드는게 나은 경우가 많다.
- 변수 추출 ↔ 변수 인라인
- 함수 선언 바꾸기
- 변수 캡슐화
    - 함수는 데이터보다 다루기 수월하다. 이름을 바꾸거나 다른 모듈로 옮기기도 쉽다.
    - 반대로 데이터는 함수보다 다루기 까다롭다. 데이터를 참조하는 모든 부분을 바꿔야 한다.
    - 따라서 그 데이터로의 접근을 독점하는 함수를 만들어 캡슐화하는 것이 좋다.
    - 데이터 변경 전후에 로직을 추가할 수도 있다.
- 변수 이름 바꾸기
- 매개변수 객체화
- 여러 함수를 클래스로 묶기
- 여러 함수를 변환 함수로 묶기
- 단계 쪼개기

`질의 함수`

- CQS에서 나온 용어
- 그냥 메서드인데 read만 하는 정도로 이해

# Ch7 - 캡슐화

- 레코드 캡슐화
    - 가변 데이터일 때, 객체로 감싸는걸 선호
    - 클라이언트가 데이터를 읽기만 한다면, 복제본이나 읽기전용 프록시 반환을 고려
    - set
        - 깊은 복사 반환
        - 읽기전용 프록시 반환 - 수정시 예외 던지기
        - 복제본을 만들고 재귀적으로 동결해 쓰기 동작 감지
    - get
- 컬렉션 캡슐화
    - 일급 컬렉션
    - 흔히 하는 실수 : 컬렉션 변수 접근은 캡슐화하면서, getter가 컬렉션 자체를 반환시키면 눈치 채지 못하는 상태에서 값이 바뀔 수 있다.
    - 복제본 반환과 읽기 전용 프록시 반환 등은 위와 비슷
    - "컬렉션에 대해선 어느정도 강박증을 갖고 불필요한 복제본을 만드는 것이, 예상치 못한 수정으로 인한 오류를 디버깅하는 것보단 낫다"
- 기본형 → 객체
    - 처음엔 큰 차이 없지만, 기능이 추가될수록 유용
- 임시 변수 → 질의 함수
    - 한줄 짜리 변수도, 함수로 추출
    - 자고로 변수는 한번만 값이 할당되고 이후론 계속 읽히기만 해야한다. - `final` 붙여보면 확인 가능
    - `옛날주소`처럼 스냅샷 용도의 변수는 본 리팩토링 부적절
- 클래스 추출 ↔ 클래스 인라인
- 위임 숨기기 ↔ 중개자 제거
    - 위임 메소드가 과하게 많아져 클래스가 중개자 역할으로만 전략된 경우 - 디미터 법칙을 너무 신봉할 때 나타난다 → '이따금씩 유용한 디미터의 제안' 정도로 부르자
- 알고리즘 교체
    - 날로먹기

# Ch8 - 기능 이동

- 함수 이동
- 필드 이동
- 문장을 함수로 이동 ↔ 문장을 호출부로 이동
- 인라인 코드 → 함수 호출
- 문장 슬라이드
    - 관련 코드는 한곳에 모은다
    - 모든 변수 선언을 함수 첫머리에 모으는 사람도 있으나, 저자와 나는 쓰이는곳에 모으는 것을 선호
    - 명령-질의 분리 원칙(Command-Query Separation)
        - 값을 반환하는 함수는 부수효과가 없다
- 반복문 쪼개기
    - 리팩터링 vs 최적화를 구분
        - 리스트 반복이 성능저하로 이어지는 경우는 생각보다 드물다
- 반복문 → 파이프 라인
    - 어느정도는 파이프화 안하고 남겨두는 것도 가독성 향상
- 죽은 코드 제거
    - 하고싶다

# Ch9 - 데이터 조직화

- 변수 쪼개기
    - 변수도 예외는 없다. 역할이 둘 이상이라면 쪼개라
- 필드 이름 바꾸기
- 파생 변수 → 질의 변수 바꾸기
    - 가변 데이터의 유효 범위를 가능한 좁혀야 한다.
- 참조를 값으로 ↔ 값을 참조로 바꾸기
    - 값 객체(불변)는 영향을 걱정할 일이 적어 자유롭게 사용하기 좋다. 따라서 분산/동시성 시스템에서 특히 유용
    - 같은 데이터를 복제해 사용할 때의 문제는 데이터 갱신. 이런 부분이 중요한 경우(는 사실 적은듯?)는 참조로
- 매직 리터럴 바꾸기
    - `String ONE = 1` 같은건 의미 없음

# Ch10 - 조건부 로직 간소화

*조건문 ← 코드가 복잡해지는 주요 원인 중 하나*

- 조건문 분해
    - if문에 'Why'에 대한 설명을 도움
- 조건식 통합
- 중첩 조건문을 보호 구문으로
    - 조건부에서 두 경로가 모두 정상이라면, if-else 활용. 양쪽에 똑같은 무게를 둠
    - 반면 한쪽만 정상이라면, 비정상쪽을 if문으로 검사해 함수를 빠져나오도록 - `보호 구문`
- 조건부 로직을 다형성으로
    - with 팩터리 함수
    - 흔히 쓰이는 `1 - N` 형태 외에, `1 - 1_adv` 형태도 가능
- 특이 케이스 추가
    - 특이 케이스 확인 코드를 함수 호출로 바꾸기 - 주로 null 검사
    - Null Object Pattern. 널 검사를 널 객체에 위임
- Assertion 추가
    - 코드가 어떤 상태임을 가정한 상태로 실행되는지 다른 개발자에게 알려주는 좋은 소통수단
- 제어 플래그를 탈출문으로

# Ch11 - API 리팩터링

- CQS (Command-Query Seperation)
    - 데이터 갱신 함수 vs 조회 함수 분리 !
- 함수 매개변수화
- 플래그 인수 제거
    - 저자는 플래그 함수를 좋아하지 않음, 플래그 변수의 의미를 한번더 알아내야 하므로. 단순히 함수 호출을 선호
- 객체 통째로 넘기기
    - 장점
        - 변화 대응에 유연
        - 매개변수 목록이 짧아져 함수 사용이 간단
        - 로직 중복 제거 가능
    - 단점
        - 함수가 데이터 구조에 의존하게 됨. 특히 서로 다른 모듈에 속한 경우
- 매개변수를 질의 함수로 ↔ 질의 함수를 매개변수로
    - 전자
        - 호출쪽을 간소하게
        - 매개변수를 없앤다고 가변전역변수를 이용하면 안됨
    - 후자
        - 호출부가 좀더 복잡해지더라도, 함수안의 의존성을 없애고 싶을 때가 있다.
        - 호출부는 복잡해지지만, 대신 함수는 `참조 투명성`을 얻고, 이로 인한 이점 역시 크다.
        - → 모듈을 개발할 때, 순수 함수들을 따로 구분하고, 입출력과 기타 가변 원소들을 다루는 로직으로 순수 함수들의 겉을 감싸는 패턴을 많이들 쓴다고 함.
    - 정답은 없다. 양끝단 사이에서 적절한 균형을 유지해야 한다.
- Setter 제거
    - 불완전한 객체를 없애고, 변경 가능성을 줄이기
- 생성자를 팩터리 함수로
    - 메서드 이름으로 더 의미를 표현할 수 있다
- 함수를 명령(클래스)으로 ↔ 명령을 함수로
    - `명령 (객체), Command`  : 함수만을 위한 객체. 메서드 하나로 구성되어 이를 실행하는 것이 목적
    - 유연성은 복잡함을 키우는 대신 얻는 대가다. 일급 함수 vs 명령이라면, 보통 95%는 일급 함수가 나을때가  많다. 꼭 필요할때만 전자의 리팩토링을 수행하자.
- 수정된 값 반환하기
- 오류 코드를 예외로
- 예외를 사전 확인으로

# Ch12 - 상속 다루기

- 메서드/필드/생성자본문 올리기
- 메서드/필드 내리기
- 타입 코드를 서브클래스로 ↔ 서브클래스 제거
    - 전자의 하위 리팩터링
        1. 타입 코드를 상태/전략 패턴으로 바꾸기
        2. 서브클래스 추출

    > 나는 무언가의 표현 방법을 바꾸려 할 때면 먼저 현재의 표현을 캡슐화하여 이 변화가 클라이언트 코드에 주는 영향을 최소화한다.

- 슈퍼클래스 추출
- 계층 합치기
- 서브클래스를 위임(조합)으로
    - 상속의 단점
        - 하나의 기준만 적용할 수 있으며, 한번 선택 후 바꿀수 도 없음.
        - 클래스 간의 관계가 결합된다.
    - 상속보단 컴포지션 (무분별한 상속보단 적절히 섞어서)
- 슈퍼클래스를 위임으로
    - 상속의 잘못된 적용 예시 : 자바의 Stack Class extends List
    - 부모클래스가 사용되는 모든 곳에서 자식클래스의 인스턴스를 대신 사용해도 괜찮아야 한다.
    - 마틴 파울러는 조합보다 상속을 우선적으로 적용하는 등, 상속을 생각보다 선호한다는 점이 인상적이었음.